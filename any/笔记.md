# any 类型

### 基本定义
`any` 类型表示没有任何限制，该类型的变量可以赋予任何类型的值。

`TypeScript` 不对其进行任何类型检查。由于这个原因，应该尽量避免使用any的类型，否则就失去了使用它的意义。

在实际开发中any主要使用一下两个场景：
1. 处于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为`any`
2. 适配老的js项目，让代码快速迁移到ts，可以把变量设为`any`

### 类型推断问题
从集合论的角度看，`any`类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层。

如果开发者没有定义类型且ts自己无法进行推断，ts会认为该变量为any。

ts提供了一个编译选项 `noImplicitAny`，打开这个选项，只有推断出any类型就会报错。


### 污染问题

any类型可以赋值给任何类型的变量：

```ts
let x:any = 'hello'
let y:number

y = x; // 不会报错
y * 123 // 不报错
y.toFixed() // 不报错
```

# unknown 类型

为了解决any类型污染其他变量的问题。ts3.0引入 `unknown` 类型。

`unknown` 跟 `any` 的相似之处，在于所有类型的值都可以分配给 `unknown` 类型。

他们的不同之处在于，它不能直接使用，主要有以下几个限制：
1. unknown 类型的变量，不能直接赋值给其他类型的变量（除了 any 类型和 unknown 类型）
2. 不能直接调用 unknown 类型变量的方法和属性
3. unknown 类型变量能够与性能的运算是有限的，只能进行比较运算只能进行比较运算（运算符`==`、`===`、`!=`、`!==`、`||`、`&&`、`?`）、取反运算（运算符`!`）、`typeof`运算符和`instanceof`运算符这几种，其他运算都会报错。

那么，怎么才能使用 unknown 类型呢？

答案就是经过`类型缩小`才可以使用。所谓类型缩小，就是缩小unknown类型变量的类型范围。  

```ts
let a: unknown = 1

if(typeof a === 'number') {
    let r = a + 10 // 正确
}
```

# never 类型

never类型可以赋值给任意类型。ts中，任何类型都包含never类型。
